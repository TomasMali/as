"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = require("uuid");
const util_1 = require("./util");
const constants = {
    OperationalError: 'OperationalError',
    ProgrammerError: 'ProgrammerError',
};
class Oops extends Error {
    constructor(options) {
        super(options.message);
        this.fullStack = () => {
            let str = this.stack || '';
            if (this.context) {
                str = str.replace(this.message + '\n', this.message + ' ' + util_1.stringifyContext(this.context) + '\n');
            }
            if (this.cause) {
                const cause = this.cause;
                str += '\n' + (cause.fullStack ? cause.fullStack() : cause.stack);
            }
            return str;
        };
        Error.captureStackTrace(this, this.constructor);
        this.name = options.name || options.category;
        this.category = options.category;
        this.context = options.context;
        this.cause = options.cause;
        this.id = uuid_1.v4();
    }
}
exports.Oops = Oops;
exports.getErrorCategory = (err) => {
    if (err && err.category) {
        return err.category;
    }
    return constants.ProgrammerError;
};
exports.programmerErrorHandler = (message, context) => {
    return err => {
        throw new Oops({
            message,
            category: exports.getErrorCategory(err),
            cause: err,
            context,
        });
    };
};
exports.operationalErrorHandler = (message, context) => {
    return err => {
        throw new Oops({
            message,
            category: constants.OperationalError,
            cause: err,
            context,
        });
    };
};
exports.assert = (value, message, context) => {
    if (!Boolean(value)) {
        throw new Oops({
            message,
            category: constants.OperationalError,
            context,
        });
    }
};
exports.newOperationalOops = (message, context) => {
    return new Oops({
        message,
        category: constants.OperationalError,
        context,
    });
};
exports.operationalOops = (message, context) => {
    throw exports.newOperationalOops(message, context);
};
exports.newProgrammerOops = (message, context, error) => {
    return new Oops({
        message,
        category: exports.getErrorCategory(error),
        context,
        cause: error,
    });
};
exports.programmerOops = (message, context) => {
    throw exports.newProgrammerOops(message, context);
};
exports.defensiveGet = (getter) => {
    try {
        return getter();
    }
    catch (e) {
        return 'accessing value returned an error: ' + e;
    }
};
//# sourceMappingURL=index.js.map